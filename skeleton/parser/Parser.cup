package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};


terminal PLUS, MINUS;
terminal TIMES, UMINUS;
terminal LPAREN, RPAREN;
terminal IF, ELSE;
terminal RETURN, SEMICOLON;
terminal PRINT;
terminal LBRACE, RBRACE;
terminal INT;
terminal LESS_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO;
terminal LESS_THAN, GREATER_THAN;
terminal EQUAL_TO, NOT_EQUAL_TO;
terminal AND, OR, NOT;
terminal ASSIGN;
terminal COMMA;

terminal Long     INTCONST;
terminal String   IDENT;


non terminal Program                program;
non terminal Expr                   expr;
non terminal BinaryExpr             binaryExpr;
non terminal Cond                   cond;
non terminal Stmt                   stmt;
non terminal List<Stmt>             stmtList;
non terminal FuncDef                funcDef;
non terminal List<FuncDef>          funcDefList;
non terminal List<String>           formalDeclList;
non terminal List<String>           neFormalDeclList;
non terminal List<Expr>             exprList;
non terminal List<Expr>             neExprList;

precedence left PRINT;
precedence left IF;
precedence left ELSE;
precedence left AND, OR;
precedence left NOT;
precedence left LESS_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, NOT_EQUAL_TO, LESS_THAN, GREATER_THAN;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;


start with program;

program ::= funcDefList:fdl
            {: RESULT = new Program(fdl, loc(fdlleft, fdlright)); :}
         ;

funcDefList ::= funcDef:fd funcDefList:fdl 
            {: fdl.add(0, fd); RESULT = fdl; :}
         |
            {: RESULT = new ArrayList<FuncDef>(); :}    
         ;

funcDef ::= INT IDENT:i LPAREN formalDeclList:fdl RPAREN LBRACE stmtList:sl RBRACE
            {: RESULT = new FuncDef(i, fdl, sl, loc(slleft, slright)); :}
         ;

formalDeclList ::= neFormalDeclList:neFormaldl
            {: RESULT = neFormaldl; :}
         |
            {: RESULT = new ArrayList<String>(); :}
         ;

neFormalDeclList ::= INT IDENT:i COMMA neFormalDeclList:nfdl
            {: nfdl.add(0, i); RESULT = nfdl; :}
         | INT IDENT:i
            {: List<String> newFormalDecls = new ArrayList<String>(); newFormalDecls.add(0, i); RESULT = newFormalDecls; :}
         ;


stmtList ::= stmt:s stmtList:l
            {: l.add(0, s); RESULT = l; :}
         |
            {: RESULT = new ArrayList<Stmt>(); :}
         ;

stmt ::= IF cond:c stmt:s1 ELSE stmt:s2
         {: RESULT = new IfStmt(c, s1, s2, loc(cleft, cright)); :}
         %prec ELSE
      | IF cond:c stmt:s
         {: RESULT = new IfStmt(c, s, null, loc(cleft, cright)); :}
         %prec IF
      | RETURN expr:e SEMICOLON
         {: RESULT = new ReturnStmt(e, loc(eleft, eright)); :}
      | PRINT expr:e SEMICOLON
         {: RESULT = new PrintStmt(e, loc(eleft, eright)); :}
      | INT IDENT:i ASSIGN expr:e SEMICOLON
         {: RESULT = new VarDeclStmt(i, e, loc(ileft, iright)); :}
      | LBRACE stmtList:sl RBRACE
         {: RESULT = new StmtList(sl, loc(slleft, slright)); :}
      ;     


expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  MINUS expr:e
         {: RESULT = new UnaryMinusExpr(UnaryMinusExpr.UMINUS, e, loc(eleft, eright)); :}
         %prec UMINUS
      |  IDENT:i
         {: RESULT = new IdentifierExpr(i, loc(ileft, iright)); :}
      |  IDENT:i LPAREN exprList:el RPAREN
         {: RESULT = new FuncCallExpr(i, el, loc(ileft, iright)); :}
      ;

exprList ::= neExprList:neEL
                  {: RESULT = neEL; :}
               |
                  {: RESULT = new ArrayList<Expr>(); :}
               ;

neExprList ::= expr:e COMMA neExprList:nel
                  {: nel.add(0, e); RESULT = nel; :}
               | expr:e
                  {: List<Expr> newExprList = new ArrayList<Expr>(); newExprList.add(0, e); RESULT = newExprList; :}
               ;


binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;


cond ::= LPAREN cond:c RPAREN
         {: RESULT = c; :}
      |  expr:e1 LESS_THAN expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.LESS_THAN, e2, loc(e1left, e1right)); :}
      |  expr:e1 LESS_THAN_OR_EQUAL_TO expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.LESS_THAN_OR_EQUAL_TO, e2, loc(e1left, e1right)); :}
      |  expr:e1 GREATER_THAN expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.GREATER_THAN, e2, loc(e1left, e1right)); :}
      |  expr:e1 GREATER_THAN_OR_EQUAL_TO expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.GREATER_THAN_OR_EQUAL_TO, e2, loc(e1left, e1right)); :}
      |  expr:e1 EQUAL_TO expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.EQUAL_TO, e2, loc(e1left, e1right)); :}
      |  expr:e1 NOT_EQUAL_TO expr:e2
         {: RESULT = new CompareCond(e1, CompareCond.NOT_EQUAL_TO, e2, loc(e1left, e1right)); :}
      |  NOT cond:c
      {: RESULT = new LogicalCond(LogicalCond.NOT, c, loc(cleft, cright)); :}
      |  cond:c1 AND cond:c2
         {: RESULT = new LogicalCond(c1, LogicalCond.AND, c2, loc(c1left, c1right)); :}
      |  cond:c1 OR cond:c2
         {: RESULT = new LogicalCond(c1, LogicalCond.OR, c2, loc(c1left, c1right)); :}
      ;